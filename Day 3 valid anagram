'''Valid Anagram 242
Easy
Company Tags
Hints
Given two strings s and t, return true if the two strings are anagrams of each other, otherwise return false.

An anagram is a string that contains the exact same characters as another string, but the order of the characters can be different.

Example 1:

Input: s = "racecar", t = "carrace"

made out of the same characters.
7 characters

Output: true

Example 2:

Input: s = "jar", t = "jam"

r!=m

Output: false
Constraints:

s and t consist of lowercase English letters.'''

#Hash map approach
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        countS, countT = {}, {}
        for i in range(len(s)):
            countS[s[i]] = 1 + countS.get(s[i], 0) # Increment count for character s[i], hashmap
            countT[t[i]] = 1 + countT.get(t[i], 0) # Increment count for character t[i], hashmap
        for c in countS:
            if countS[c] != countT.get(c, 0): # Compare counts of each character in both hashmaps
                return False
        return True
# Time Complexity: O(n+m) where n and m are the lengths of strings s and t respectively
# Space Complexity: O(1) since the character set is limited to lowercase English letters


# Alternative approach using sorting (dont take extra space)
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        
        return sorted(s) == sorted(t)
# Time Complexity: O(n log n) due to sorting
# Space Complexity: O(1) if we ignore the space used by sorting algorithm, otherwise o(n+m)


#hash table using array 
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False
        
        count = [0] * 26  # Since there are 26 lowercase English letters
        
        for i in range(len(s):
            count[ord(s[i]) - ord('a')] += 1  # Increment count for character in s
            count[ord(t[i]) - ord('a')] -= 1  # Decrement count for character in t

        for val in count:
            if val != 0:
                return False
        return True

# Time Complexity: O(n) where n is the length of the strings
# Space Complexity: O(1) since the size of the count array is fixed (26